/* Main.c file generated by New Project wizard
 *
 * Created:   2020
 * Processor: PIC18F45K22
 * Compiler:  MPLAB XC8
 */
#include <stdio.h>
#include <xc.h>
#define _XTAL_FREQ 8000000  

#include <string.h>
#include "config.h"
#include "GLCD.h"
#define EST_RUNNING 	0	//estat de la partida, si està en marxa (RUNNING == 1) o si està parat (RUNNING == 0)
#define EST_END 	0

//Variables globals
char bonus[5];			//vector per a controlar si hi ha bonus 
int i_bonus = 0;		//índex del vector bonus
unsigned int RUNNING = EST_RUNNING;
unsigned int END = EST_END;
int points = 0;			//0 punts a l'inici
int max_points = 0;		//puntuació màxima obtinguda, el record de puntuació
int lives = 3;			//3 vides a l'inici
int pos_robot = 1;  		//posició del robot a l'inici de la partida
int posx_pic = 1;		//posició de l'objecte PIC
int posy_pic = 2;		//posició de l'objecte PIC
//caràcters per controlar els polsos dels buttons
char RA1 = '1';
char RA2 = '1';
char RA22 = '1';
char RA3 = '1';
char RA32 = '1';
char RA4 = '1';
char RA5 = '1';
char inici_cicle = '0';
char inici_cicle2 = '1';
int delay;			//velocitat a la que cauen els objectes, determinat pel valor del potenciometre
int valor;			//valor del potenciometre
char primer = '1';			
char segon = '1';
char tercer = '1';

//configuració de la GLCD
void configGLCD(void){
   ANSELD = 0x00;		//PORTB configurat com a digital
   ANSELB = 0x00;		//PORTD configurat com a digital
   PORTD = 0x00; 		//Valors inicials al PORTD
   PORTB = 0x00;  		//Valors inicials al PORTB
   TRISD = 0x00;		//PORTD configurat com a sortida
   TRISB = 0x00;		//PORTB configurat com a sortida
   GLCDinit();		   	//Inicialitzem la pantalla	
   clearGLCD(0,7,0,127);      	//Esborrem la pantalla
   setStartLine(0);           	//Definim la linia d'inici
}

//configuració del timer0
void configTimers(void) {
   T0CONbits.T08BIT = 0;	//Timer 0 is configured as a 16-bit timer
   T0CONbits.T0CS = 0;		//Instruction cycle clock
   T0CONbits.T0SE = 1;		//Increment on rising edge transition on T0CKL
   T0CONbits.PSA = 0;		//Timer0 prescaler is assigned
   T0CONbits.T0PS2 = 1;		//1:128 prescaler value
   T0CONbits.T0PS1 = 1;		//1:128 prescaler value
   T0CONbits.T0PS0 = 0;		//1:128 prescaler value
   RCONbits.IPEN = 1; 		//Enables priority interrupt
   //about INTCON
   INTCONbits.GIEH = 1; 	//Enables all high-priority interrupts
   INTCONbits.GIEL = 1; 	//Enables all low-priority interrupts
   INTCONbits.GIE = 1;		//Enables all interrupts
   INTCONbits.PEIE = 1; 	//Enables peripheral interrupts 
   INTCONbits.TMR0IE = 1;	//Enables the timer 0 overflow interrupt
   INTCON2bits.TMR0IP = 1;	//Timer 0 overflow interrupt high priority
     /*
      El timer0 s'ha de inicialitzar amb el valor 0XC2F7, que en decimal es 49911. I surt 
      de la fórmula T(rsi) = n* T(cicle_clock) * PRESCALER  => 1s = n * 1/(8000000/4) * 128 => n = 15625
      llavors com que el timer0 és de 16 bits, 2^16 - 15625 =  49911 i en hexadecimal es 0xC2F7
      */
   TMR0H = 0xC2;
   TMR0L = 0xF7;
   T0CONbits.TMR0ON = 0;	//Enables timer 0
}

//configuració del PIC per la línia sèrie
void config_linia_serie(void) {
   RCSTA1bits.SPEN = 1; 	//enable USART port 
   TRISC = 0xFF;		//configurats com a outputs
   ANSELC = 0x00;		//PORTC configurat com a digital
   BAUDCON1bits.BRG16 = 1;	//16-bits Baud Rate
   TXSTA1bits.TX9 = 0;		//selects 8-bits transmission
   TXSTA1bits.TXEN = 1;		//transmit enabled	
   TXSTA1bits.SYNC = 0;		//asynchronous mode
   TXSTA1bits.BRGH = 1;		//high speed
   SPBRG1 = 16; 		//Set de Baud rate
   PIE1bits.TXIE = 0; 		//disable transmit interrupt 
   PIE1bits.RC1IE = 1;		//enable receive interrupt
   IPR1bits.RC1IP = 0;		//EUSART1 Receive Interrupt as low-priority
   RCSTA1bits.CREN = 1;		//Enables receiver
   PORTA = 0x00;		//valors inicials del PORTA
   TRISA = 0x00;		//PORTA configurats com a inputs 
   ANSELA = 0x00;		//PORTA configurats com a digitals
}

//configuració del Pic per al potenciometre
void configPotenciometre() {
   TRISAbits.TRISA0 = 1; 	//bit RA0 configurat com a entrada
   ANSELAbits.ANSA0 = 1;	//bit RA0 configurat com a analògic
   ADCON2bits.ADCS0 = 1;	//A/D Conversion Clock = Fosc/8
   ADCON2bits.ADCS1 = 0;	//A/D Conversion Clock = Fosc/8
   ADCON2bits.ADCS2 = 0;	//A/D Conversion Clock = Fosc/8
   ADCON1bits.PVCFG0 = 0;	//A/D connected to internal signal AVdd
   ADCON1bits.PVCFG1 = 0;	//A/D connected to internal signal AVdd
   ADCON1bits.NVCFG0 = 0;	//A/D connected to internal signal AVss
   ADCON1bits.NVCFG1 = 0;	//A/D connected to internal signal AVss
   ADCON0bits.CHS0 = 0; 	//AN0 as analog channel
   ADCON0bits.CHS1 = 0;		//AN0 as analog channel
   ADCON0bits.CHS2 = 0;		//AN0 as analog channel
   ADCON0bits.CHS3 = 0;		//AN0 as analog channel
   ADCON0bits.CHS4 = 0;		//AN0 as analog channel	 
   ADCON2bits.ACQT0 = 0;	//Tacq = 4 Tad
   ADCON2bits.ACQT1 = 1;	//Tacq = 4 Tad
   ADCON2bits.ACQT2 = 0;	//Tacq = 4 Tad
   ADCON2bits.ADFM = 1;		//Right justified
   ADCON0bits.ADON = 1;		//Enable ADC
}

//funció que dibuixa les vides que té el jugador
void dibuixar_vides(void) {
   //si en té 0, borra totes les vides
   if (lives == 0) {
      clearGLCD(0,0,95,125);
   }
   //si només en té 1
   else if (lives == 1) {
      clearGLCD(0,0,100,125);
      putchGLCD(0, 19, '"'); 
   }
   //si només en té 2
   else if (lives == 2) {
      clearGLCD(0,0,110,125);
      putchGLCD(0, 19, '"');
      putchGLCD(0, 21, '"');
   }
   //si en té 3
   else if (lives == 3) {
      putchGLCD(0, 19, '"');
      putchGLCD(0, 21, '"');
      putchGLCD(0, 23, '"');
   }
}

//funció que dibuixa el robot
void dibuixar_robot(void) {
   putchGLCD(6, pos_robot - 1 , '(');  //els caràcters estàn editats
   putchGLCD(6, pos_robot, ')');  
   putchGLCD(6, pos_robot + 1 , '*'); 
   putchGLCD(7, pos_robot - 1 , '+'); 
   putchGLCD(7, pos_robot, ',');  
   putchGLCD(7, pos_robot + 1 , '-'); 
}

//funcio que dibuixa els punts que té 
void dibuixar_punts(void) {
   clearGLCD(0,0,45,55);
   //si només té una xifra
   if (points < 10) {
      writeNum(0, 9, points);
   }
   //si té més d'una xifra
   else if (points >= 10) {
      writeNum(0, 9, points/10);
      writeNum(0, 10, points%10);
   }
}

//funció que dibuixa la capçalera de la partida
void dibuixar_grafic(void) {
   char grafic1[7] = {'P','o','i','n','t','s',':'};
   char grafic2[6] = {'L','i','v','e','s',':'};
   int j = 0;
   for (int i = 1; i < 8; ++i) {
      putchGLCD(0, i, grafic1[j]);
      ++j;
   }
   j = 0;
   for (int i = 13; i < 19; ++i) {
      putchGLCD(0, i, grafic2[j]);
      ++j;
   }
}

//funció que dibuixa l'obejecte a recollir
void dibuixa_pic(void) {
   putchGLCD(posx_pic,posy_pic,'?'); //el caràcter '?' està editat 
}

//funció que dibuixa el final d'una partida quan ja no li queden vides al jugador
void dibuixa_final_partida() {
   char defeat[6] = {'D','E','F','E','A','T'};
   char score[11] = {'y', 'o', 'u', 'r', '|', 's', 'c', 'o', 'r', 'e', ':'};
   char record[14] = {'h', 'i', 'g', 'h', 'e', 's', 't', '|', 's', 'c', 'o', 'r', 'e', ':'};
   //per dibuixar "DEFEAT"
   int j = 0;
   for (int i = 7; i < 20; i += 2) {
      putchGLCD(0, i, defeat[j]);
      ++j;
   }
   //per dibuixar "your score: puntuació"
   j = 0;
   for (int i = 5; i < 16; ++i) {
      putchGLCD(4, i, score[j]);
      ++j;
   }
   //per dibuixar "highest score: max_puntuació"
   j = 0;
   for (int i = 5; i < 19; ++i) {
      putchGLCD(2, i, record[j]);
      ++j;
   }
   //per dibuixar els punts obtinguts
   //si només té una xifra
   if (points < 10) {
      writeNum(4, 16, points);
   }
   //si només té més d'una xifra
   else if (points >= 10) {
      writeNum(4, 16, points/10);
      writeNum(4, 17, points%10);
   }
   //per dibuixar el màxim de punts(el record)
   //si només té una xifra
   if (points > max_points) max_points = points;
   if (max_points < 10) {
      writeNum(2, 19, max_points);
   }
   //si només té més d'una xifra
   else if (max_points >= 10) {
      writeNum(2, 19, max_points/10);
      writeNum(2, 20, max_points%10);
   }   
   //per dibuixar "RA1 => restart button" que indica quin botó ha de clicar per reiniciar la partida
   char ra1[23] = {'R', 'A', '1', '/', 's', '|', '=', '>', '|', 'r', 'e', 's', 't', 'a', 'r', 't', '|','b', 'u', 't', 't', 'o', 'n'}; 
   j = 0;
   for (int i = 1; i < 24; ++i) {
      putchGLCD(6, i, ra1[j]);
      ++j;
   }
   //Quan acabi la partida li envia un text a la terminal amb els punts obtinguts 
   int i = 0;
   char str[24];
   sprintf(str, "\r\nHAS OBTINGUT %d PUNTS \r\n", points);
   while(i < 24) { 
      while (!PIR1bits.TX1IF);
      TXREG1 = str[i];
      ++i;
   }
}

//funció que dibuixa la pàgina de pausa
void dibuixa_pagina_pausa(void) {
   //RA1 or s => continuar partida
   //RA5 or t => començar nova partida 
   char pausa[5] = {'P','A','U','S','A'};
   int j = 0;
   for (int i = 7; i < 19; i += 2) {
      putchGLCD(0, i, pausa[j]);
      ++j;
   }
   char continuar[25] = {'R', 'A', '1', '/', 's', '|', '=', '>', '|', 'c', 'o', 'n', 't', 'i', 'n', 'u', 'a', '|', 'p', 'a', 'r', 't', 'i', 'd', 'a'}; 
   j = 0;
   for (int i = 0; i < 25; ++i) {
      putchGLCD(2, i, continuar[j]);
      ++j;
   }
   char nou[21] = {'R', 'A', '5', '/', 't', '|', '=', '>', '|', 'n', 'o', 'v', 'a', '|', 'p', 'a', 'r', 't', 'i', 'd', 'a'}; 
   j = 0;
   for (int i = 0; i < 21; ++i) {
      putchGLCD(3, i, nou[j]);
      ++j;
   }
}

//funció que dibuixa la pàgina de inici
void dibuixa_pagina_inici(void) {
   //RA1 or s => botó start, iniciar/reanudar partida
   //RA2 or d => moure cap a l'esquerra
   //RA3 or a => moure cap a la dreta
   //RA4 or f => parar partida
   //RA5 or t => resetejar la partida 
   char inici[9] = {'B','E','N','V','I', 'N', 'G', 'U', 'T'};
   int j = 0;
   for (int i = 4; i < 22; i += 2) {
      putchGLCD(0, i, inici[j]);
      ++j;
   }
   //moure cap a la dreta
   char ra1[21] = {'R', 'A', '1', '/', 's', '|', '=', '>', '|', 's', 't', 'a', 'r', 't', '|','b', 'u', 't', 't', 'o', 'n'}; 
   j = 0;
   for (int i = 1; i < 22; ++i) {
      putchGLCD(2, i, ra1[j]);
      ++j;
   }
   //moure cap a l'esquerra
   char ra2[18] = {'R', 'A', '2', '/', 'a', '|', '=', '>', '|', 'm', 'o', 'v', 'e', '|','l', 'e', 'f', 't'}; 
   j = 0;
   for (int i = 1; i < 19; ++i) {
      putchGLCD(3, i, ra2[j]);
      ++j;
   }
   //moure cap a la dreta
   char ra3[19] = {'R', 'A', '3', '/', 'd', '|', '=', '>', '|', 'm', 'o', 'v', 'e', '|','r', 'i', 'g', 'h', 't'}; 
   j = 0;
   for (int i = 1; i < 20; ++i) {
      putchGLCD(4, i, ra3[j]);
      ++j;
   }
   //pausar la partida
   char ra4[20] = {'R', 'A', '4', '/', 'f', '|', '=', '>', '|', 's', 't', 'o', 'p', '|', 'b', 'u', 't', 't', 'o', 'n'}; 
   j = 0;
   for (int i = 1; i < 21; ++i) {
      putchGLCD(5, i, ra4[j]);
      ++j;
   }
   //reiniciar la partida
   char ra5[21] = {'R', 'A', '5', '/', 't', '|', '=', '>', '|', 'r', 'e', 's', 'e', 't', '|', 'b', 'u', 't', 't', 'o', 'n'}; 
   j = 0;
   for (int i = 1; i < 22; ++i) {
      putchGLCD(6, i, ra5[j]);
      ++j;
   }
} 

//funció que escriu pel Virtual Terminal
void puts_usart1 (void) {
   char benvingut[28];
   sprintf(benvingut, "BENVINGUT AL JOC JIABO WANG\r\n");//missatge de benvinguda
   int i = 0;
   while(i < 28) {
      while (!PIR1bits.TX1IF);
      TXREG1 = benvingut[i];
      ++i;
   }
   //per escriure les instruccions del joc
   char instruccions[148];
   sprintf(instruccions, "INSTRUCCIONS \r\na PER ANAR A L'ESQUERRA \r\nd PER ANAR A LA DRETA \r\ns PER INICIAR LA PARTIDA \r\nt PER REINICIAR LA PARTIDA \r\nf PER PAUSAR LA PARTIDA \r\n");
   i = 0;
   while(i < 148) {
      while (!PIR1bits.TX1IF);
      TXREG1 = instruccions[i];
      ++i;
   } 
   //per explicar el bonus
   char hack[33];
   sprintf(hack, "ESCRIURE BONUS AUGMENTA UNA VIDA\r\n");//missatge per al bonus
   int i = 0;
   while(i < 33) {
      while (!PIR1bits.TX1IF);
      TXREG1 = hack[i];
      ++i;
   }
}

//funció d'interrupció de baixa prioritat que llegeix del Virtual Terminal
void interrupt low_priority control(void) {
   if (PIR1bits.RCIF == 1) {
      //moure cap a la dreta
      if (RCREG1 == 'd' && RUNNING == 1) {
	 RA3 = '0';
      }
      //moure cap a la esquerra
      if (RCREG1 == 'a' && RUNNING == 1) {
	 RA2 = '0';
      }
      //per iniciar una partida
      if (RCREG1 == 's' && RUNNING == 0) {
	 RA1 = '0';
      }
      //per reiniciar una partida
      if (RCREG1 == 't') {
	 RA5 = '0';
      }
      //per pausar una partida
      if (RCREG1 == 'f' && RUNNING == 1) {
	 RUNNING = 0;
	 RA4 = '0';
      }
      //comprobar si s'escriu bonus
      if (i_bonus > 4) {
	 bonus[0] = bonus[1];
	 bonus[1] = bonus[2];
	 bonus[2] = bonus[3];
	 bonus[3] = bonus[4];
	 bonus[4] = RCREG1;
      }
      else {
	 bonus[i_bonus] = RCREG1;
	 ++i_bonus;
      }
      //si hi ha bonus, llavors s'incrementa una vida
      if ((bonus[0] == 'b' &&  bonus[1] == 'o' &&  bonus[2] == 'n' &&  bonus[3] == 'u' &&  bonus[4] == 's') || (bonus[0] == 'B' &&  bonus[1] == 'O' &&  bonus[2] == 'N' &&  bonus[3] == 'U' &&  bonus[4] == 'S')) {
	 if (lives < 3) ++lives;
      }
   }
}  

//funció que fa un desplaçament cap a la dreta o cap a l'esquerra del robot
void moviment(void) {
   //desplaçament cap a la dreta
   if (PORTAbits.RA3 == 1 && RA3 == '1') {
      RA3 = '0';
   }
   if (RA3 == '0' && RA32 == '1') {
      if (pos_robot < 24) ++pos_robot;
      clearGLCD(6,7,0,127); 
      dibuixar_robot();
      dibuixar_grafic();
      RA32 = '0';
   }
   if (PORTAbits.RA3 == 0) {
      RA3 = '1';
      RA32 = '1';
   }
   //Desplaçament cap a l'esquerra
   if (PORTAbits.RA2 == 1 && RA2 == '1') {
      RA2 = '0';
   }
   if (RA2 == '0' && RA22 == '1') {
      if (pos_robot > 1) --pos_robot;
      clearGLCD(6,7,0,127); 
      dibuixar_robot();
      dibuixar_grafic();
      RA22 = '0';
   }
   if (PORTAbits.RA2 == 0) {
      RA2 = '1';
      RA22 = '1';
   }
}

//interrupció d'alta prioritat associat per al timer 0
void interrupt high_priority tic(void) {
   if(INTCONbits.TMR0IF == 1 && INTCONbits.TMR0IE == 1 && primer == '0') {
      inici_cicle = '1';
      /*
      El timer0 ha de tenir el valor 0XC2F7, que en decimal es 49911. I surt 
      de la fórmula T(rsi) = n* T(cicle_clock) * PRESCALER  => 1s = n * 1/(8000000/4) * 128 => n = 15625
      llavors com que el timer0 és de 16 bits, 2^16 - 15625 =  49911 i en hexadecimal es 0xC2F7
      */
      TMR0H = 0xC2;
      TMR0L = 0xF7;
      INTCONbits.TMR0IF = 0;
   }
   else if(INTCONbits.TMR0IF == 1 && INTCONbits.TMR0IE == 1 && primer == '1') {
      inici_cicle = '1';
      /*
      El timer0 ha de tenir el valor 0X48E5, que en decimal es 18661. I surt 
      de la fórmula T(rsi) = n* T(cicle_clock) * PRESCALER  => 3s = n * 1/(8000000/4) * 128 => n = 46875
      llavors com que el timer0 és de 16 bits, 2^16 - 46875 = 18661 i en hexadecimal es 0x48E5
      */
      TMR0H = 0x48;
      TMR0L = 0xE5;
      INTCONbits.TMR0IF = 0;
   }
} 

//funció que converteix la dada analògic a digital i el guarda al paràmetre "valor"
void convertir_dada_potenciometre(void) {
   ADCON0bits.GO = 1; 			//Demanem una conversió
   while(ADCON0bits.GO){} 		//Espera activa a que ens confirmi la lectura
   valor = ADRESH << 8;			//Obtenció de la dada
   valor += ADRESL;			//Obtenció de la dada
}

//programa principal
void main(void) {
   configGLCD();
   configTimers();
   config_linia_serie();
   configPotenciometre();
   while (1) {
      if (primer == '1') {
	 TMR0H = 0x48;
	 TMR0L = 0xE5;
	 T0CONbits.TMR0ON = 1;
	 dibuixar_portada();
	 while(inici_cicle == '0');
	 inici_cicle = '1';
	 T0CONbits.TMR0ON = 0;	 
	 clearGLCD(0,7,0,127); 
	 primer = '0';			//Només al principi del programa
      }
      else {
	 if (segon == '1') {		
	    clearGLCD(0,7,0,127); 
	    segon = '0';	
	    puts_usart1();		//Enviar missatge de benviguda només un cop al principi
	 }
	 else {				
	    if (tercer == '1') {
	       dibuixa_pagina_inici();	//Mostra la pàgina d'inici
	       tercer = '0';
	    }
	    else {
	       //RA1 per posar en marxa la partida (en flanc descendent) 
	       if (PORTAbits.RA1 == 1 && RA1 == '1' && RUNNING == 0) {
		  RA1 = '0';
	       }
	       if (PORTAbits.RA1 == 0 && RA1 == '0') {
		  if (END == 1) {	//Netejar les estadístiques de la partida anterior
		     END = 0;
		     lives = 3;
		     points = 0;
		  }
		  RA1 = '1';
		  clearGLCD(0,7,0,127);
		  int number = 4;
		  inici_cicle = '0';
		  configTimers();
		  T0CONbits.TMR0ON = 1; //enable timer0
		  while (number > 0) {	//Mostrar START durant tres segons a l'inici d'una partida
		     if (number == 1) {
			clearGLCD(0,7,0,127);
			char start[5] = {'S', 'T', 'A', 'R', 'T'}; 
			int j = 0;
			for (int i = 10; i < 15; ++i) {
			   putchGLCD(4, i, start[j]);
			   ++j;
			}
		     }
		     else {
			writenumbers(2, 55, (number-1));
		     }
		     while(inici_cicle == '0');
		     inici_cicle = '0';
		     --number;
		  }
		  T0CONbits.TMR0ON = 0; //disable timer0
		  clearGLCD(0,7,0,127);
		  dibuixar_robot();
		  dibuixar_grafic();
		  dibuixar_vides();
		  dibuixar_punts();
		  RUNNING = 1;		//posar en mode RUNNING la partida
	       }
	       //RA4 per parar la partida (en flanc descendent)
	       if (PORTAbits.RA4 == 1 && RA4 == '1' && RUNNING == 1) {
		  RUNNING = 0;
		  RA4 = '0';
	       }
	       if (PORTAbits.RA4 == 0 && RA4 == '0') {
		  RA4 = '1';
		  clearGLCD(0,7,0,127); 
		  dibuixa_pagina_pausa(); //posar en pausa la partida
	       }
	       //RA5 per tornar a començar la partida si estaba en una partida, si no, es resetegen els valors de vida i punts (en flanc descendent)
	       if (PORTAbits.RA5 == 1 && RA5 == '1') {
		  RA5 = '0';
	       }
	       if (PORTAbits.RA5 == 0 && RA5 == '0') {
		  RA5 = '1';
		  points = 0;								
		  lives = 3;
		  pos_robot = 1;
		  posx_pic = 1;		//posició de l'objecte PIC
		  posy_pic = 2;
		  clearGLCD(0,7,0,127); 
		  int number = 4;
		  inici_cicle = '0';
		  configTimers();
		  T0CONbits.TMR0ON = 1;	//enable timer0
		  while (number > 0) {	//mostrar durant tres segons START a l'inici de la nova partida
		     if (number == 1) {
			clearGLCD(0,7,0,127);
			char start[5] = {'S', 'T', 'A', 'R', 'T'}; 
			int j = 0;
			for (int i = 10; i < 15; ++i) {
			   putchGLCD(4, i, start[j]);
			   ++j;
			}
		     }
		     else {
			writenumbers(2, 55, (number-1));
		     }
		     while(inici_cicle == '0');
		     inici_cicle = '0';
		     --number;
		  }
		  T0CONbits.TMR0ON = 0;	//disable timer0
		  clearGLCD(0,7,0,127);
		  dibuixar_robot();
		  dibuixar_grafic();
		  dibuixar_vides();
		  dibuixar_punts();
		  if (RUNNING == 0) RUNNING = 1;
	       }
	       // si la partida està en marxa
	       if (RUNNING) {
		 convertir_dada_potenciometre();
		 delay = valor+100;
		 moviment(); //si la partida està en marxa, llavors pot moure's cap a la dreta o cap a l'esquerra
		 int p = 0;
		 while (p < delay) { //caiguda de l'objecte
		    __delay_ms(1);
		    moviment();
		    if (PORTAbits.RA5 == 1 && RA5 == '1') {
		     RA5 = '0';
		     RUNNING = 0;
		     p = delay + 1;
		    }
		    if (PORTAbits.RA4 == 1 && RA4 == '1' && RUNNING == 1) {
		     RUNNING = 0;
		     RA4 = '0';
		     p = delay + 1;
		    }
		    ++p;
		 } 
		 if (RUNNING) {
		  //si s'agafa l'objecte sumar punts
		  if ((posx_pic == 6 && posy_pic == pos_robot - 1) || (posx_pic == 7 && posy_pic == pos_robot - 1) || (posx_pic == 6 && posy_pic == pos_robot) || (posx_pic == 7 && posy_pic == pos_robot) || (posx_pic == 6 && posy_pic == pos_robot + 1) || (posx_pic == 7 && posy_pic == pos_robot + 1)) {
		    posx_pic = 1;
		    posy_pic = rand() % (24+1);
		    ++points;
		    dibuixar_punts();
		  } 
		  else if (posx_pic < 7) {
		    clearGLCD(posx_pic, posx_pic, posy_pic*5, (posy_pic*5)+5);
		    ++posx_pic;
		    //si s'agafa l'objecte sumar punts
		    if ((posx_pic == 6 && posy_pic == pos_robot - 1) || (posx_pic == 6 && posy_pic == pos_robot) || (posx_pic == 6 && posy_pic == pos_robot + 1)) {
		     posx_pic = 1;
		     posy_pic = rand() % (24+1);
		     ++points;
		     dibuixar_punts();
		    } 
		    else dibuixa_pic();
		  }
		  else if (posx_pic == 7) {
		    //si s'agafa l'objecte sumar punts
		    if ((posx_pic == 7 && posy_pic == pos_robot - 1) || (posx_pic == 7 && posy_pic == pos_robot) || (posx_pic == 7 && posy_pic == pos_robot + 1)) {
			posx_pic = 1;
			posy_pic = rand() % (24+1);
			++points;
		        dibuixar_punts();
		    }
		    else {
			clearGLCD(posx_pic, posx_pic, posy_pic*5, (posy_pic*5)+5);
			dibuixa_pic();
			clearGLCD(posx_pic, posx_pic, posy_pic*5, (posy_pic*5)+5);
			posx_pic = 1;
			posy_pic = rand() % (24+1);
			--lives;
			if (lives == 0) {
			   RUNNING = 0;
			   clearGLCD(0,7,0,127); 
			   dibuixa_final_partida();
			   END = 1;
			}
		     }
		  }    
		  dibuixar_vides();
		 }
	       }
	    }
	 }
      }
   }
}