/* Main.c file generated by New Project wizard
 *
 * Created:   2020
 * Processor: PIC18F45K22
 * Compiler:  MPLAB XC8
 */

#include <xc.h>
#define _XTAL_FREQ 	8000000
#define EST_RUNNING 	1
#define EST_MINUTS	0
#define EST_HORES 	0

#include <string.h>
#include "config.h"
#include "GLCD.h"

int hores = 0;				//indica el valor de les hores del temporitzador
int minuts = 0;				//indica el valor dels minuts del temporitzador
int segons = 0;				//indica el valor dels segons del temporitzador
int speed = 0;

unsigned int RUNNING = EST_RUNNING; 	//0 si no està en RUNNING i 1 si ho està 
unsigned int MINUTS = EST_MINUTS;	//0 si no està en INIT i 1 si ho està 
unsigned int HORES = EST_HORES; 	//0 si no està en STOPPED i 1 si ho està 

char inici_cicle = '1';			//char que actua com a boleà per controlar l'entrada/sortida del RSI
char funcionamentc = '1';  		//char que actua com a boleà i controla el funcionament del programa
char c1 = '0';				//char que actua com a boleà i controla el flanc de pujada del botó associat al RC0
char c2 = '0';
char c3 = '0';
char c4 = '0';
char funcionament2 = '0';
char funcionament3 = '0';

//interrupció d'alta prioritat associat per al timer 0
void interrupt high_priority tic(void) {
   if(INTCONbits.TMR0IF == 1 && INTCONbits.TMR0IE == 1) {
      inici_cicle = '1';
      /*
      El timer0 ha de tenir el valor 0XF3CB, que en decimal es 62411. I surt 
      de la fórmula T(rsi) = n* T(cicle_clock) * PRESCALER  => 0.1s = n * 1/(8000000/4) * 64 => n = 31250
      llavors com que el timer0 és de 16 bits, 2^16 - 31250 = 34286 i en hexadecimal es 0x85EE 
      */
      if (speed == 0) { //velocitat normal
	 TMR0H = 0x85;
	 TMR0L = 0xEE;
      }
      else if (speed == 1) {	//velocitat x10
	 TMR0H = 0xF3;
	 TMR0L = 0xCB;
      }
      else if (speed == 2) {	//velocitat x100
	 TMR0H = 0xFE;
	 TMR0L = 0xC7;
      }
      INTCONbits.TMR0IF = 0;
   }
}

//funció que mostra el valor del comptador de temps en el format hh:mm:ss.d
void mostrar_numero() {
   if (minuts < 0) {	//quan queden menys de un minut, passa a 59 segons
      minuts = 59;
   }
   if (hores < 0) {	//quan queden menys de una hora, passa a 59 minuts
      hores = 23;
   } 
   if (segons > 59) {
      segons = 0; 
      ++minuts;
   }
   if (minuts > 59) {	//quan queden menys de un minut, passa a 59 segons
      minuts = 0;
      ++hores;
   }
   if (hores > 23) {	//quan queden menys de una hora, passa a 59 minuts
      hores = 0;
   }
   if (hores < 10) {	//si hores només té un valor (menor que 10), afegeixo un valor 0 al seu esquerre
      writeNum(6, 0, 0);
      writeNum(6, 1, hores);
   }
   if (minuts < 10) {	//si minuts només té un valor (menor que 10), afegeixo un valor 0 al seu esquerre
      writeNum(6, 3, 0);
      writeNum(6, 4, minuts);
   }
   if (segons < 10) {	//si segons només té un valor (menor que 10), afegeixo un valor 0 al seu esquerre
      writeNum(6, 6, 0);
      writeNum(6, 7, segons);
   }
   if (segons > 9) {	//si segons té dos valors (major que 9), el mostro per pantalla directament
      writeNum(6, 6, segons);
   }
   if (minuts > 9) {	//si minuts té dos valors (major que 9), el mostro per pantalla directament
      writeNum(6, 3, minuts);
   }
   if (hores > 9) {	//si hores té dos valors (major que 9), el mostro per pantalla directament
      writeNum(6, 0, hores);
   }
   putchGLCD(6, 2, ':');
   putchGLCD(6, 5, ':');
}

//conté totes les configuracions necessàries per al bon funcionament del programa
void config() {
   T0CONbits.TMR0ON = 1;	//Enables timer 0
   T0CONbits.T08BIT = 0;	//Timer 0 is configured as a 16-bit timer
   T0CONbits.T0CS = 0;		//Instruction cycle clock
   T0CONbits.T0SE = 1;		//Increment on rising edge transition on T0CKL
   T0CONbits.PSA = 0;		//Timer0 prescaler is assigned
   T0CONbits.T0PS2 = 1;
   T0CONbits.T0PS1 = 0;		//1:64 prescaler value
   T0CONbits.T0PS0 = 1;
   INTCONbits.GIE = 1;		//Enables all interrupts
   INTCONbits.PEIE = 1; 	//Enables peripheral interrupts 
   INTCONbits.TMR0IE = 1;	//Enables the timer 0 overflow interrupt
   INTCON2bits.TMR0IP = 1;	//Timer 0 overflow interrupt high priority
   /*
      El timer0 s'ha d'inicialitzar amb el valor 0XF3CB, que en decimal es 62411. I surt 
      de la fórmula T(rsi) = n* T(cicle_clock) * PRESCALER  => 0.1s = n * 1/(8000000/4) * 64 => n = 31250
      llavors com que el timer0 és de 16 bits, 2^16 - 31250 = 34286 i en hexadecimal es 0x85EE 
   */
   TMR0H = 0x85;
   TMR0L = 0xEE;
   ANSELC = 0;			//PORTC configurat com Digital
   ANSELD = 0;                  //PORTD configurat com Digital
   ANSELB = 0;                  //PORTB configurat com Digital
   PORTC = 0x00;		//Donem uns valors inicials als ports C, D i B
   PORTD = 0x00; 		  
   PORTB = 0x00;
   TRISC = 0xFF;		//PORTC configurat com a entrada
   TRISD = 0x00;		//PORTD configurat com a sortida
   TRISB = 0x00;		//PORTB configurat com a sortida
   GLCDinit();		   	//Inicialitzem la pantalla
   clearGLCD(0,7,0,127);      	//Esborrem pantalla
   setStartLine(0);           	//Definim linia d'inici
   mostrar_numero();
}

//Funció que controla els flancs ascendents del bit RC0 i executa el seu corresponent codi per al bon funcionament del progama
void funcionament_programa() {
   if (PORTCbits.RC0 == 1 && c1 == '0') {	//prenem botó RC0
      if (MINUTS == 1) {//si estaba en el mode MINUTS, passa a estar al mode RUNNING
	 MINUTS = 0;
	 RUNNING = 1;
      }
      else if (RUNNING == 1) {
	 RUNNING = 0;	//si estaba en el mode RUNNING, passa a estar al mode HORES
	 HORES = 1;
      }
      else if (HORES == 1) {
	 HORES = 0;	//si estaba en el mode HORES, passa a estar al mode MINUTS
	 MINUTS = 1;
      }
      funcionamentc = '1';
      c1 = '1';
   }
   if (funcionamentc == '1' && MINUTS == 1) {	//mode MINUT, que deixa cambiar els minuts
      if (PORTCbits.RC1 == 1 && c2 == '0') {
	 ++minuts;
	 mostrar_numero();
	 c2 = '1';
      } 
      if (PORTCbits.RC2 == 1 && c3 == '0') {
	 --minuts;
	 mostrar_numero();
	 c3 = '1';
      } 
   }
   else if (funcionamentc == '1' && RUNNING == 1) {//mode RUNNING
      ++segons;
      mostrar_numero();      		 //mostrem els valors
   }
   else if (funcionamentc == '1' && HORES == 1) {//mode MINUTS, que deixa cambiar els minuts
      if (PORTCbits.RC1 == 1 && c2 == '0') {
	 ++hores;
	 mostrar_numero();
	 c2 = '1';
      } 
      if (PORTCbits.RC2 == 1 && c3 == '0') {
	--hores;
	 mostrar_numero();
	 c3 = '1';
      } 
   }
   if (PORTCbits.RC0 == 0) {
      c1 = '0';
   }
   if (PORTCbits.RC1 == 0) {
      c2 = '0';
   }
   if (PORTCbits.RC2 == 0) {
      c3 = '0';
   }
}

void main(void) {
   config();
   while (1) {
      if (RUNNING == 1) {
	 while(inici_cicle == '0') {	//espera activa, surt quan li arriba el enable flag al timer0 (que s'executa cada 0.1 segons)
	    if (PORTCbits.RC0 == 1 && RUNNING == 1 && c1 == '0') {
	       RUNNING = 0;
	       HORES = 1;
	       inici_cicle = '1';
	       funcionamentc = '1';
	       c1 = '1';
	    }
	    if (PORTCbits.RC0 == 1 && HORES == 1 && c1 == '0') {
	       HORES = 0;
	       MINUTS = 1;
	       inici_cicle = '1';
	       funcionamentc = '1';
	       c1 = '1';
	    } 
	    if (PORTCbits.RC3 == 1 && c4 == '0') {
	       ++speed;
	       if (speed > 2) speed = 0;
	       c4 = '1';
	    }  
	 }
	 inici_cicle = '0';
      }
      funcionament_programa();		//comença a executar-se el programa
      if (PORTCbits.RC3 == 1 && c4 == '0') {
	 ++speed;
	 if (speed > 2) speed = 0;
	 c4 = '1';
      }
      if (PORTCbits.RC3 == 0) c4 = '0';
   }
}